<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïù∏Í∞ÑÏ†ÅÏù∏ AI ÏßÄÎ¢∞Ï∞æÍ∏∞!</title>
    <style>
        :root { --board-bg: #c0c0c0; --cell-border: #808080; --cell-border-light: #ffffff; --revealed-bg: #bdbdbd; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; user-select: none; }
        #game-container { padding: 20px; background-color: var(--board-bg); border: 3px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); box-shadow: 5px 5px 15px rgba(0,0,0,0.2); text-align: center; }
        h1 { margin-top: 0; }
        .menu { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #restart, #ai-solve { padding: 8px 15px; font-size: 16px; border: 2px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); background-color: var(--board-bg); cursor: pointer; margin-left: 5px; }
        #restart:active, #ai-solve:active { border-color: var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); }
        #ai-solve:disabled { cursor: not-allowed; color: #888; }
        .status-bar { display: flex; justify-content: space-between; padding: 10px; margin-bottom: 15px; border: 3px solid var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); background-color: #333; color: #ff0000; font-family: 'Courier New', Courier, monospace; font-size: 24px; font-weight: bold; }
        #game-board-wrapper { border: 3px solid var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); }
        #game-board { display: grid; }
        .cell { width: 25px; height: 25px; background-color: var(--board-bg); border: 2px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); display: flex; justify-content: center; align-items: center; font-size: 16px; font-weight: bold; cursor: pointer; }
        .cell.revealed { background-color: var(--revealed-bg); border: 1px solid #7b7b7b; }
        .cell.flagged { font-size: 16px; }
        .cell.mine { background-color: #ff0000; }
        .cell[data-count="1"] { color: #0000ff; } .cell[data-count="2"] { color: #008200; } .cell[data-count="3"] { color: #ff0000; } .cell[data-count="4"] { color: #000084; } .cell[data-count="5"] { color: #840000; } .cell[data-count="6"] { color: #008284; } .cell[data-count="7"] { color: #840084; } .cell[data-count="8"] { color: #757575; }
        #result-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 30px 50px; background-color: rgba(0, 0, 0, 0.75); color: white; font-size: 48px; font-weight: bold; border-radius: 10px; z-index: 100; pointer-events: none; }
        #result-message.hidden { display: none; }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Ïù∏Í∞ÑÏ†ÅÏù∏ AI ÏßÄÎ¢∞Ï∞æÍ∏∞! ü§ñ</h1>
        <div class="menu">
            <div class="difficulty">
                <!-- ÎÇúÏù¥ÎèÑ Î≤ÑÌäº ÏóÜÏùå -->
            </div>
            <div>
                <button id="ai-solve">AI ÌîåÎ†àÏù¥</button> <button id="restart">ÏÉà Í≤åÏûÑ</button>
            </div>
        </div>
        <div class="status-bar">
            <div id="mine-counter">ÎÇ®ÏùÄ ÏßÄÎ¢∞: 99</div> <div id="timer">ÏãúÍ∞Ñ: 0</div>
        </div>
        <div id="game-board-wrapper"><div id="game-board"></div></div>
        <div id="result-message" class="hidden"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const hardSettings = { width: 30, height: 16, mines: 99 };
            let width, height, minesCount, board = [], isGameOver = false, isFirstClick = true, flags = 0, timerInterval, time = 0, aiInterval;
            let isAiPlaying = false; 

            const boardElement = document.getElementById('game-board'), mineCounterElement = document.getElementById('mine-counter'), timerElement = document.getElementById('timer'), resultMessageElement = document.getElementById('result-message'), restartButton = document.getElementById('restart'), aiSolveButton = document.getElementById('ai-solve');
            
            restartButton.addEventListener('click', setupGame);
            aiSolveButton.addEventListener('click', solveWithAI);
            
            function setupGame() {
                const settings = hardSettings;
                width = settings.width; height = settings.height; minesCount = settings.mines; 
                isGameOver = false; isFirstClick = true; isAiPlaying = false; 
                flags = 0; time = 0; 
                clearInterval(timerInterval); clearInterval(aiInterval); 
                timerElement.innerText = `ÏãúÍ∞Ñ: ${time}`; 
                mineCounterElement.innerText = `ÎÇ®ÏùÄ ÏßÄÎ¢∞: ${minesCount - flags}`; 
                resultMessageElement.classList.add('hidden'); 
                aiSolveButton.disabled = false; 
                createBoard();
            }

            function createBoard() {
                board = []; 
                boardElement.innerHTML = ''; 
                boardElement.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        row.push({ y, x, isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0 });
                        const cellElement = document.createElement('div'); 
                        cellElement.classList.add('cell'); 
                        cellElement.dataset.y = y; 
                        cellElement.dataset.x = x; 
                        cellElement.addEventListener('click', () => handleCellClick(y, x)); 
                        cellElement.addEventListener('contextmenu', (e) => { e.preventDefault(); handleRightClick(y, x); }); 
                        boardElement.appendChild(cellElement);
                    }
                    board.push(row);
                }
            }

            function placeMines(firstClickY, firstClickX) {
                let minesPlaced = 0;
                while (minesPlaced < minesCount) {
                    const y = Math.floor(Math.random() * height); 
                    const x = Math.floor(Math.random() * width);
                    const isSafeZone = Math.abs(y - firstClickY) <= 1 && Math.abs(x - firstClickX) <= 1;
                    if (!board[y][x].isMine && !(y === firstClickY && x === firstClickX) && !isSafeZone) { 
                        board[y][x].isMine = true; 
                        minesPlaced++; 
                    }
                }
                for (let y = 0; y < height; y++) { 
                    for (let x = 0; x < width; x++) { 
                        if (!board[y][x].isMine) board[y][x].adjacentMines = countAdjacentMines(y, x); 
                    } 
                }
            }

            function getNeighbors(y, x) { 
                const neighbors = []; 
                for (let yo = -1; yo <= 1; yo++) { 
                    for (let xo = -1; xo <= 1; xo++) { 
                        if (yo === 0 && xo === 0) continue; 
                        const ny = y + yo; 
                        const nx = x + xo; 
                        if (ny >= 0 && ny < height && nx >= 0 && nx < width) neighbors.push(board[ny][nx]); 
                    } 
                } 
                return neighbors; 
            }

            function countAdjacentMines(y, x) { 
                let count = 0; 
                getNeighbors(y, x).forEach(n => { if (n.isMine) count++; }); 
                return count; 
            }

            function startTimer() { 
                clearInterval(timerInterval); 
                timerInterval = setInterval(() => { 
                    if (!isGameOver) { 
                        time++; 
                        timerElement.innerText = `ÏãúÍ∞Ñ: ${time}`; 
                    } 
                }, 1000); 
            }
            
            function handleCellClick(y, x) { 
                if (isAiPlaying || isGameOver || board[y][x].isRevealed || board[y][x].isFlagged) return false; 
                if (isFirstClick) { 
                    placeMines(y, x); 
                    isFirstClick = false; 
                    startTimer(); 
                } 
                const cell = board[y][x]; 
                cell.isRevealed = true; 
                revealCellDOM(y, x); 
                if (cell.isMine) { 
                    gameOver(false); 
                } else { 
                    if (cell.adjacentMines === 0) getNeighbors(y, x).forEach(n => handleCellClick(n.y, n.x)); 
                    checkWin(); 
                } 
                return true; 
            }

            function handleRightClick(y, x) { 
                if (isAiPlaying || isGameOver || board[y][x].isRevealed) return false; 
                const cell = board[y][x]; 
                const cellElement = document.querySelector(`[data-y='${y}'][data-x='${x}']`); 
                cell.isFlagged = !cell.isFlagged; 
                if (cell.isFlagged) { 
                    flags++; 
                    cellElement.innerText = 'üö©'; 
                } else { 
                    flags--; 
                    cellElement.innerText = ''; 
                } 
                mineCounterElement.innerText = `ÎÇ®ÏùÄ ÏßÄÎ¢∞: ${minesCount - flags}`; 
                return true; 
            }

            function revealCellDOM(y, x) { 
                const cell = board[y][x]; 
                const cellElement = document.querySelector(`[data-y='${y}'][data-x='${x}']`); 
                cellElement.classList.add('revealed'); 
                if (cell.isMine) { 
                    cellElement.innerText = 'üí£'; 
                    cellElement.classList.add('mine'); 
                } else if (cell.adjacentMines > 0) { 
                    cellElement.innerText = cell.adjacentMines; 
                    cellElement.dataset.count = cell.adjacentMines; 
                } 
            }
            function checkWin() { 
                const revealedCount = board.flat().filter(cell => cell.isRevealed).length; 
                if (revealedCount === width * height - minesCount && !isGameOver) gameOver(true); 
            }
            function gameOver(isWin) { 
                isGameOver = true; 
                isAiPlaying = false; 
                clearInterval(timerInterval); 
                clearInterval(aiInterval); 
                aiSolveButton.disabled = true; 
                board.flat().forEach(cell => { 
                    if (cell.isMine) revealCellDOM(cell.y, cell.x); 
                    if (!cell.isMine && cell.isFlagged) document.querySelector(`[data-y='${cell.y}'][data-x='${cell.x}']`).innerText = '‚ùå'; 
                }); 
                resultMessageElement.innerText = isWin ? 'üéâ ÏÑ±Í≥µ! üéâ' : 'üí• Ïã§Ìå® üí•'; 
                resultMessageElement.classList.remove('hidden'); 
            }

            // --- Îçî Î©çÏ≤≠Ìï¥ÏßÑ AI Î°úÏßÅ ---
            const MISTAKE_RATE = 0.60; 

            function solveWithAI() {
                aiSolveButton.disabled = true;
                
                // *** Ïó¨Í∏∞Í∞Ä ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§ ***
                // 1. AIÏùò Ï≤´ ÌÅ¥Î¶≠ÏùÑ Î®ºÏ†Ä Ïã§ÌñâÌï¥ÏÑú Í≤åÏûÑÏùÑ ÏãúÏûëÏãúÌÇµÎãàÎã§.
                if (isFirstClick) {
                    // ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú handleCellClickÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÎåÄÏã†, ÌïÑÏöîÌïú Î°úÏßÅÎßå ÏàòÌñâ
                    const startY = Math.floor(Math.random() * height);
                    const startX = Math.floor(Math.random() * width);
                    placeMines(startY, startX);
                    isFirstClick = false;
                    startTimer();
                    board[startY][startX].isRevealed = true;
                    revealCellDOM(startY, startX);
                }
                
                // 2. Í≤åÏûÑ ÏãúÏûëÏù¥ ÌôïÏ†ïÎêú ÌõÑ, AI ÌîåÎ†àÏù¥ ÏÉÅÌÉúÎ°ú Ï†ÑÌôòÌïòÏó¨ ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÑ ÎßâÏäµÎãàÎã§.
                isAiPlaying = true;
                aiInterval = setInterval(aiTurn, 100);
            }


            function aiTurn() {
                if (isGameOver) { clearInterval(aiInterval); return; }
                
                if (Math.random() < MISTAKE_RATE) {
                    makeProbabilisticGuess();
                    checkWin();
                    return;
                }

                if (findAndMakeCertainMove()) {
                    checkWin(); return;
                }

                makeProbabilisticGuess();
                checkWin();
            }

            function findAndMakeCertainMove() {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cell = board[y][x];
                        if (!cell.isRevealed || cell.adjacentMines === 0) continue;
                        const neighbors = getNeighbors(y, x);
                        const hidden = neighbors.filter(n => !n.isRevealed && !n.isFlagged);
                        const flagged = neighbors.filter(n => n.isFlagged);
                        if (hidden.length === 0) continue;
                        
                        // AIÎäî handleCellClick, handleRightClickÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÏßÄ ÏïäÍ≥† ÎÇ¥Î∂Ä Î°úÏßÅÏùÑ Î∞îÎ°ú Ïã§Ìñâ
                        if (cell.adjacentMines - flagged.length === hidden.length) {
                            for (const n of hidden) { 
                                if (!n.isFlagged) { // Ï§ëÎ≥µ ÍπÉÎ∞ú Î∞©ÏßÄ
                                    n.isFlagged = true;
                                    flags++;
                                    document.querySelector(`[data-y='${n.y}'][data-x='${n.x}']`).innerText = 'üö©';
                                }
                            }
                            mineCounterElement.innerText = `ÎÇ®ÏùÄ ÏßÄÎ¢∞: ${minesCount - flags}`;
                            return true;
                        }
                        
                        if (cell.adjacentMines === flagged.length) {
                            for (const n of hidden) {
                                n.isRevealed = true;
                                revealCellDOM(n.y, n.x);
                                if (n.isMine) { gameOver(false); return true; }
                                if (n.adjacentMines === 0) getNeighbors(n.y, n.x).forEach(neighbor => handleCellClick(neighbor.y, neighbor.x));
                            }
                            return true;
                        }
                    }
                }
                return false;
            }

            function makeProbabilisticGuess() {
                const hidden = board.flat().filter(c => !c.isRevealed && !c.isFlagged);
                if (hidden.length === 0) return;

                let bestGuess = null;
                let lowestProb = 1.0;

                for (const cell of hidden) {
                    const neighbors = getNeighbors(cell.y, cell.x).filter(n => n.isRevealed);
                    if (neighbors.length > 0) {
                        let prob = 1.0;
                        for(const n of neighbors) {
                            const n_neighbors = getNeighbors(n.y, n.x);
                            const n_hidden = n_neighbors.filter(c => !c.isRevealed && !c.isFlagged).length;
                            const n_flagged = n_neighbors.filter(c => c.isFlagged).length;
                            if (n_hidden > 0) {
                                prob = Math.min(prob, (n.adjacentMines - n_flagged) / n_hidden);
                            }
                        }
                        if (prob < lowestProb) {
                            lowestProb = prob;
                            bestGuess = cell;
                        }
                    }
                }
                
                let cellToClick;
                if (bestGuess) {
                    cellToClick = bestGuess;
                } else {
                    cellToClick = hidden[Math.floor(Math.random() * hidden.length)];
                }
                
                // AI ÌÅ¥Î¶≠ Î°úÏßÅ
                cellToClick.isRevealed = true;
                revealCellDOM(cellToClick.y, cellToClick.x);
                if (cellToClick.isMine) { 
                    gameOver(false); 
                } else {
                    if (cellToClick.adjacentMines === 0) getNeighbors(cellToClick.y, cellToClick.x).forEach(n => handleCellClick(n.y, n.x));
                }
            }
            
            setupGame();
        });
    </script>
</body>
</html>