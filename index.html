<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïù∏Í∞ÑÏ†ÅÏù∏ AI ÏßÄÎ¢∞Ï∞æÍ∏∞!</title>
    <style>
        :root { --board-bg: #c0c0c0; --cell-border: #808080; --cell-border-light: #ffffff; --revealed-bg: #bdbdbd; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; user-select: none; }
        #game-container { padding: 20px; background-color: var(--board-bg); border: 3px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); box-shadow: 5px 5px 15px rgba(0,0,0,0.2); text-align: center; }
        h1 { margin-top: 0; }
        .menu { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .difficulty button, #restart, #ai-solve { padding: 8px 15px; font-size: 16px; border: 2px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); background-color: var(--board-bg); cursor: pointer; margin-left: 5px; }
        .difficulty button:active, #restart:active, #ai-solve:active { border-color: var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); }
        #ai-solve:disabled { cursor: not-allowed; color: #888; }
        .status-bar { display: flex; justify-content: space-between; padding: 10px; margin-bottom: 15px; border: 3px solid var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); background-color: #333; color: #ff0000; font-family: 'Courier New', Courier, monospace; font-size: 24px; font-weight: bold; }
        #game-board-wrapper { border: 3px solid var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); }
        #game-board { display: grid; }
        .cell { width: 25px; height: 25px; background-color: var(--board-bg); border: 2px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); display: flex; justify-content: center; align-items: center; font-size: 16px; font-weight: bold; cursor: pointer; }
        .cell.revealed { background-color: var(--revealed-bg); border: 1px solid #7b7b7b; }
        .cell.flagged { font-size: 16px; }
        .cell.mine { background-color: #ff0000; }
        .cell[data-count="1"] { color: #0000ff; } .cell[data-count="2"] { color: #008200; } .cell[data-count="3"] { color: #ff0000; } .cell[data-count="4"] { color: #000084; } .cell[data-count="5"] { color: #840000; } .cell[data-count="6"] { color: #008284; } .cell[data-count="7"] { color: #840084; } .cell[data-count="8"] { color: #757575; }
        #result-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 30px 50px; background-color: rgba(0, 0, 0, 0.75); color: white; font-size: 48px; font-weight: bold; border-radius: 10px; z-index: 100; pointer-events: none; }
        #result-message.hidden { display: none; }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Ïù∏Í∞ÑÏ†ÅÏù∏ AI ÏßÄÎ¢∞Ï∞æÍ∏∞! ü§ñ</h1>
        <div class="menu">
            <div class="difficulty">
                <button id="easy">Ï¥àÍ∏â</button> <button id="medium">Ï§ëÍ∏â</button> <button id="hard">Í≥†Í∏â</button>
            </div>
            <div>
                <button id="ai-solve">AI ÌîåÎ†àÏù¥</button> <button id="restart">ÏÉà Í≤åÏûÑ</button>
            </div>
        </div>
        <div class="status-bar">
            <div id="mine-counter">ÎÇ®ÏùÄ ÏßÄÎ¢∞: 10</div> <div id="timer">ÏãúÍ∞Ñ: 0</div>
        </div>
        <div id="game-board-wrapper"><div id="game-board"></div></div>
        <div id="result-message" class="hidden"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Í∏∞Î≥∏ Í≤åÏûÑ Î°úÏßÅ (ÏàòÏ†ï ÏóÜÏùå) ---
            const difficulties = { easy: { width: 9, height: 9, mines: 10 }, medium: { width: 16, height: 16, mines: 40 }, hard: { width: 30, height: 16, mines: 99 } };
            let currentDifficulty = 'easy', width, height, minesCount, board = [], isGameOver = false, isFirstClick = true, flags = 0, timerInterval, time = 0, aiInterval;
            const boardElement = document.getElementById('game-board'), mineCounterElement = document.getElementById('mine-counter'), timerElement = document.getElementById('timer'), resultMessageElement = document.getElementById('result-message'), restartButton = document.getElementById('restart'), easyButton = document.getElementById('easy'), mediumButton = document.getElementById('medium'), hardButton = document.getElementById('hard'), aiSolveButton = document.getElementById('ai-solve');
            restartButton.addEventListener('click', () => setupGame(currentDifficulty)); easyButton.addEventListener('click', () => setupGame('easy')); mediumButton.addEventListener('click', () => setupGame('medium')); hardButton.addEventListener('click', () => setupGame('hard')); aiSolveButton.addEventListener('click', solveWithAI);
            function setupGame(difficulty) {
                currentDifficulty = difficulty; const settings = difficulties[difficulty]; width = settings.width; height = settings.height; minesCount = settings.mines; isGameOver = false; isFirstClick = true; flags = 0; time = 0; clearInterval(timerInterval); clearInterval(aiInterval); timerElement.innerText = `ÏãúÍ∞Ñ: ${time}`; mineCounterElement.innerText = `ÎÇ®ÏùÄ ÏßÄÎ¢∞: ${minesCount - flags}`; resultMessageElement.classList.add('hidden'); aiSolveButton.disabled = false; createBoard();
            }
            function createBoard() {
                board = []; boardElement.innerHTML = ''; boardElement.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        row.push({ y, x, isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0 });
                        const cellElement = document.createElement('div'); cellElement.classList.add('cell'); cellElement.dataset.y = y; cellElement.dataset.x = x; cellElement.addEventListener('click', () => handleCellClick(y, x)); cellElement.addEventListener('contextmenu', (e) => { e.preventDefault(); handleRightClick(y, x); }); boardElement.appendChild(cellElement);
                    }
                    board.push(row);
                }
            }
            function placeMines(firstClickY, firstClickX) {
                let minesPlaced = 0;
                while (minesPlaced < minesCount) {
                    const y = Math.floor(Math.random() * height); const x = Math.floor(Math.random() * width);
                    const isSafeZone = Math.abs(y - firstClickY) <= 1 && Math.abs(x - firstClickX) <= 1;
                    if (!board[y][x].isMine && !(y === firstClickY && x === firstClickX) && !isSafeZone) { board[y][x].isMine = true; minesPlaced++; }
                }
                for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { if (!board[y][x].isMine) board[y][x].adjacentMines = countAdjacentMines(y, x); } }
            }
            function getNeighbors(y, x, b = board) { const neighbors = []; for (let yo = -1; yo <= 1; yo++) { for (let xo = -1; xo <= 1; xo++) { if (yo === 0 && xo === 0) continue; const ny = y + yo; const nx = x + xo; if (ny >= 0 && ny < height && nx >= 0 && nx < width) neighbors.push(b[ny][nx]); } } return neighbors; }
            function countAdjacentMines(y, x) { let count = 0; getNeighbors(y, x).forEach(n => { if (n.isMine) count++; }); return count; }
            function startTimer() { clearInterval(timerInterval); timerInterval = setInterval(() => { if (!isGameOver) { time++; timerElement.innerText = `ÏãúÍ∞Ñ: ${time}`; } }, 1000); }
            function handleCellClick(y, x) { if (isGameOver || board[y][x].isRevealed || board[y][x].isFlagged) return false; if (isFirstClick) { placeMines(y, x); isFirstClick = false; startTimer(); } const cell = board[y][x]; cell.isRevealed = true; revealCellDOM(y, x); if (cell.isMine) { gameOver(false); } else { if (cell.adjacentMines === 0) getNeighbors(y, x).forEach(n => handleCellClick(n.y, n.x)); checkWin(); } return true; }
            function handleRightClick(y, x) { if (isGameOver || board[y][x].isRevealed) return false; const cell = board[y][x]; const cellElement = document.querySelector(`[data-y='${y}'][data-x='${x}']`); cell.isFlagged = !cell.isFlagged; if (cell.isFlagged) { flags++; cellElement.innerText = 'üö©'; } else { flags--; cellElement.innerText = ''; } mineCounterElement.innerText = `ÎÇ®ÏùÄ ÏßÄÎ¢∞: ${minesCount - flags}`; return true; }
            function revealCellDOM(y, x) { const cell = board[y][x]; const cellElement = document.querySelector(`[data-y='${y}'][data-x='${x}']`); cellElement.classList.add('revealed'); if (cell.isMine) { cellElement.innerText = 'üí£'; cellElement.classList.add('mine'); } else if (cell.adjacentMines > 0) { cellElement.innerText = cell.adjacentMines; cellElement.dataset.count = cell.adjacentMines; } }
            function checkWin() { const revealedCount = board.flat().filter(cell => cell.isRevealed).length; if (revealedCount === width * height - minesCount && !isGameOver) gameOver(true); }
            function gameOver(isWin) { isGameOver = true; clearInterval(timerInterval); clearInterval(aiInterval); aiSolveButton.disabled = true; board.flat().forEach(cell => { if (cell.isMine) revealCellDOM(cell.y, cell.x); if (!cell.isMine && cell.isFlagged) document.querySelector(`[data-y='${cell.y}'][data-x='${cell.x}']`).innerText = '‚ùå'; }); resultMessageElement.innerText = isWin ? 'üéâ ÏÑ±Í≥µ! üéâ' : 'üí• Ïã§Ìå® üí•'; resultMessageElement.classList.remove('hidden'); }

            // --- Ïù∏Í∞ÑÏ†ÅÏù∏ AI Î°úÏßÅ (Human-like AI Logic) ---
            const MISTAKE_RATE = 0.15; // AIÍ∞Ä Ïã§ÏàòÌï† ÌôïÎ•† (15%). Ïù¥ Í∞íÏùÑ Ï°∞Ï†àÌïòÏó¨ ÎÇúÏù¥ÎèÑ Î≥ÄÍ≤Ω Í∞ÄÎä•!

            function solveWithAI() {
                aiSolveButton.disabled = true;
                if (isFirstClick) handleCellClick(0, 0);
                aiInterval = setInterval(aiTurn, 75); // AIÏùò 'ÏÉùÍ∞Å' ÏÜçÎèÑ
            }

            function aiTurn() {
                if (isGameOver) { clearInterval(aiInterval); return; }
                
                // 1Îã®Í≥Ñ: Í∏∞Î≥∏ ÎÖºÎ¶¨Î°ú ÌôïÏã§Ìïú Ïàò 'ÌïòÎÇò'Î•º Ï∞æÏïÑÏÑú Îë†
                if (findAndMakeCertainMove(board)) {
                    checkWin(); return;
                }
                
                // [Ïù∏Í∞ÑÏ†ÅÏù∏ Ïã§Ïàò] ÏùºÏ†ï ÌôïÎ•†Î°ú Ïñ¥Î†§Ïö¥ ÏÉùÍ∞ÅÏùÑ Í±¥ÎÑàÎúÄ
                if (Math.random() < MISTAKE_RATE) {
                    // 2Îã®Í≥ÑÎ•º Í±¥ÎÑàÎõ∞Í≥† Î∞îÎ°ú 3Îã®Í≥Ñ(ÏÑ±Í∏âÌïú Ï∂îÏ∏°)Î°ú ÎÑòÏñ¥Í∞ê
                    makeProbabilisticGuess();
                    checkWin();
                    return;
                }

                // 2Îã®Í≥Ñ: Í≥†Í∏â ÎÖºÎ¶¨(Í∑ÄÎ•òÎ≤ï)Î°ú 'ÌïòÎÇò'Ïùò ÏàòÎ•º Ï∞æÏïÑÏÑú Îë†
                if (makeAdvancedMove()) {
                    checkWin(); return;
                }

                // 3Îã®Í≥Ñ: Î™®Îì† ÎÖºÎ¶¨Î°ú ÎßâÌòîÏùÑ Îïå, ÏµúÌõÑÏùò ÏàòÎã®ÏúºÎ°ú ÌôïÎ•†Ï†Å Ï∂îÏ∏° 'ÌïòÎÇò'Î•º Ìï®
                makeProbabilisticGuess();
                checkWin();
            }

            function findAndMakeCertainMove(currentBoard, isSimulation = false) {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cell = currentBoard[y][x];
                        if (!cell.isRevealed || cell.adjacentMines === 0) continue;
                        const neighbors = getNeighbors(y, x, currentBoard);
                        const hidden = neighbors.filter(n => !n.isRevealed && !n.isFlagged);
                        const flagged = neighbors.filter(n => n.isFlagged);
                        if (hidden.length === 0) continue;
                        if (cell.adjacentMines - flagged.length === hidden.length) {
                            for (const n of hidden) { if (isSimulation) n.isFlagged = true; else handleRightClick(n.y, n.x); }
                            return true;
                        }
                        if (cell.adjacentMines === flagged.length) {
                            for (const n of hidden) { if (isSimulation) n.isRevealed = true; else handleCellClick(n.y, n.x); }
                            return true;
                        }
                    }
                }
                return false;
            }

            function makeAdvancedMove() {
                const frontier = board.flat().filter(c => !c.isRevealed && !c.isFlagged && getNeighbors(c.y, c.x).some(n => n.isRevealed));
                for (const cell of frontier) {
                    if (isContradiction(cell, true)) { handleCellClick(cell.y, cell.x); return true; }
                    if (isContradiction(cell, false)) { handleRightClick(cell.y, cell.x); return true; }
                }
                return false;
            }

            function isContradiction(cellToTest, assumeMine) {
                const boardCopy = createLightweightCopy(board);
                if (assumeMine) { boardCopy[cellToTest.y][cellToTest.x].isFlagged = true; }
                else { boardCopy[cellToTest.y][cellToTest.x].isRevealed = true; }
                while (findAndMakeCertainMove(boardCopy, true)) {}
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const cell = boardCopy[y][x];
                        if (cell.isRevealed) {
                            const neighbors = getNeighbors(y, x, boardCopy);
                            const flagged = neighbors.filter(n => n.isFlagged).length;
                            const hidden = neighbors.filter(n => !n.isRevealed && !n.isFlagged).length;
                            if (flagged > cell.adjacentMines || (hidden === 0 && flagged !== cell.adjacentMines)) return true;
                        }
                    }
                }
                return false;
            }
            
            function createLightweightCopy(originalBoard) {
                return originalBoard.map(row => row.map(cell => ({ y: cell.y, x: cell.x, isRevealed: cell.isRevealed, isFlagged: cell.isFlagged, adjacentMines: cell.adjacentMines })));
            }

            function makeProbabilisticGuess() {
                const hidden = board.flat().filter(c => !c.isRevealed && !c.isFlagged);
                if (hidden.length === 0) return;
                let bestGuess = { y: -1, x: -1, prob: 2 };
                for (const cell of hidden) {
                    let minProb = 1;
                    const neighbors = getNeighbors(cell.y, cell.x).filter(n => n.isRevealed);
                    if (neighbors.length > 0) {
                        for (const n of neighbors) {
                            const n_neighbors = getNeighbors(n.y, n.x);
                            const n_hidden = n_neighbors.filter(c => !c.isRevealed && !c.isFlagged).length;
                            const n_flagged = n_neighbors.filter(c => c.isFlagged).length;
                            if (n_hidden > 0) minProb = Math.min(minProb, (n.adjacentMines - n_flagged) / n_hidden);
                        }
                    }
                    if (minProb < bestGuess.prob) bestGuess = { y: cell.y, x: cell.x, prob: minProb };
                }
                if (bestGuess.y !== -1) handleCellClick(bestGuess.y, bestGuess.x);
                else handleCellClick(hidden[0].y, hidden[0].x);
            }
            setupGame('easy');
        });
    </script>
</body>
</html>