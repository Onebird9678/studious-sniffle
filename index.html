<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í”Œë ˆì´ì–´ vs AI ì§€ë¢°ì°¾ê¸° ì„œë°”ì´ë²Œ!</title>
    <style>
        :root { --board-bg: #c0c0c0; --cell-border: #808080; --cell-border-light: #ffffff; --revealed-bg: #bdbdbd; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f2f5; user-select: none; }
        
        #rules-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 200; display: flex; justify-content: center; align-items: center; }
        #rules-modal { background-color: #f0f2f5; padding: 25px 40px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-width: 500px; text-align: left; line-height: 1.6; }
        #rules-modal h2, #rules-modal h3 { text-align: center; margin-top: 0; margin-bottom: 15px; }
        #rules-modal ul { padding-left: 20px; margin-top: 0; }
        #rules-modal button { display: block; width: 100%; padding: 12px; font-size: 18px; font-weight: bold; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 20px; }
        #rules-modal-overlay.hidden { display: none; }

        #global-menu { margin-bottom: 20px; }
        #start-competition { padding: 10px 20px; font-size: 18px; font-weight: bold; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; }
        #start-competition:disabled { background-color: #a5d6a7; cursor: not-allowed; }
        
        #main-container { display: flex; justify-content: center; align-items: flex-start; gap: 40px; width: 100%; }
        .game-instance-container { position: relative; padding: 20px; background-color: var(--board-bg); border: 3px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); box-shadow: 5px 5px 15px rgba(0,0,0,0.2); text-align: center; }
        
        .board-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 10; display: flex; justify-content: center; align-items: center; font-size: 32px; color: white; font-weight: bold; pointer-events: none; border-radius: 2px; }
        .board-overlay.hidden { display: none; }

        h1 { margin-top: 0; }
        .status-bar { display: flex; justify-content: space-between; padding: 10px; margin-bottom: 15px; border: 3px solid var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); background-color: #333; color: #ff0000; font-family: 'Courier New', Courier, monospace; font-size: 24px; font-weight: bold; }
        .game-board-wrapper { border: 3px solid var(--cell-border); border-right-color: var(--cell-border-light); border-bottom-color: var(--cell-border-light); }
        .game-board { display: grid; }
        
        .cell { width: 25px; height: 25px; background-color: var(--board-bg); border: 2px solid var(--cell-border-light); border-right-color: var(--cell-border); border-bottom-color: var(--cell-border); display: flex; justify-content: center; align-items: center; font-size: 16px; font-weight: bold; }
        .cell.player-cell { cursor: pointer; }
        .cell.revealed { background-color: var(--revealed-bg); border: 1px solid #7b7b7b; }
        .cell.flagged { font-size: 16px; }
        .cell.mine { background-color: #ff0000; }
        .cell.wrong-flag { background-color: #ffcccc; }
        
        .cell.cell-preview { background-color: var(--revealed-bg); border: 1px solid #7b7b7b; }

        .cell[data-count="1"] { color: #0000ff; } .cell[data-count="2"] { color: #008200; } .cell[data-count="3"] { color: #ff0000; } .cell[data-count="4"] { color: #000084; } .cell[data-count="5"] { color: #840000; } .cell[data-count="6"] { color: #008284; } .cell[data-count="7"] { color: #840084; } .cell[data-count="8"] { color: #757575; }
        
        #result-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 30px 50px; background-color: rgba(0, 0, 0, 0.85); color: white; font-size: 48px; font-weight: bold; border-radius: 10px; z-index: 100; pointer-events: none; text-align: center; }
        #result-message.hidden { display: none; }
        #result-message small { font-size: 24px; display: block; margin-top: 10px; font-weight: normal; }
    </style>
</head>
<body>
    <div id="rules-modal-overlay">
        <div id="rules-modal">
            <h2>ì§€ë¢°ì°¾ê¸° ëŒ€ê²° ê·œì¹™!</h2>
            <p><strong>ëª©í‘œ:</strong> ì§€ë¢°(ğŸ’£)ë¥¼ ë°Ÿì§€ ì•Šê³  ëª¨ë“  ì§€ë¢°ë¥¼ ì°¾ì•„ë‚´ì„¸ìš”!</p>
            <ul>
                <li><strong>ì¢Œí´ë¦­ (ì§§ê²Œ):</strong>
                    <ul>
                        <li>ë‹«íŒ ì¹¸ì„ í´ë¦­: ì¹¸ì„ **ì˜êµ¬ì ìœ¼ë¡œ ì—½ë‹ˆë‹¤.**</li>
                        <li>ì—´ë¦° ìˆ«ì ì¹¸ì„ í´ë¦­: ì£¼ë³€ ì¹¸ë“¤ì„ **ì‹¤ì œë¡œ ì—½ë‹ˆë‹¤.**
                            <br> - (ì•ˆì „ ëª¨ë“œ: ì£¼ë³€ ê¹ƒë°œì´ ì—†ìœ¼ë©´ ì•ˆì „í•œ ì¹¸ë§Œ ì—´ë¦¼)
                            <br> - (ìœ„í—˜ ëª¨ë“œ: ì£¼ë³€ ê¹ƒë°œì´ ìˆìœ¼ë©´ íŒë‹¨ì´ í‹€ë¦´ ì‹œ ê²Œì„ ì¢…ë£Œ)
                        </li>
                    </ul>
                </li>
                 <li><strong>ì¢Œí´ë¦­ (ê¾¹ ëˆ„ë¥´ê¸°):</strong>
                    <ul>
                        <li>ì—´ë¦° ìˆ«ì ì¹¸ ìœ„ì—ì„œ ê¾¹ ëˆ„ë¥´ë©´, **ì£¼ë³€ì„ ì—¿ë³´ëŠ” ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥ë§Œ** ì‘ë™í•©ë‹ˆë‹¤.</li>
                        <li>ë§ˆìš°ìŠ¤ë¥¼ ë–¼ë©´ ë¯¸ë¦¬ë³´ê¸°ëŠ” ì‚¬ë¼ì§€ê³ , ì•„ë¬´ ì¹¸ë„ ì—´ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.</li>
                    </ul>
                </li>
                <li><strong>ìš°í´ë¦­:</strong> ê¹ƒë°œ(ğŸš©)ì„ ê½‚ìŠµë‹ˆë‹¤.</li>
            </ul>
            <h3>vs AI ëŒ€ê²° ê·œì¹™</h3>
            <p>AIì™€ ë‹¹ì‹ ì˜ ê²Œì„ì´ <strong>ëª¨ë‘ ëë‚˜ì•¼</strong> ìŠ¹íŒ¨ê°€ ê²°ì •ë©ë‹ˆë‹¤. ìµœì¢…ì ìœ¼ë¡œ <strong>ì§€ë¢°ë¥¼ ë” ì •í™•í•˜ê²Œ ë§ì´ ì°¾ì€ ìª½</strong>ì´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤!</p>
            <button id="close-rules-modal">ê²Œì„ ì‹œì‘í•˜ê¸°</button>
        </div>
    </div>

    <div id="global-menu">
        <button id="start-competition">ëŒ€ê²° ì‹œì‘</button>
    </div>

    <div id="main-container">
        <!-- HTML êµ¬ì¡°ëŠ” ë™ì¼ -->
        <div id="player-game" class="game-instance-container">
            <div id="player-overlay" class="board-overlay hidden">ê²Œì„ ì¢…ë£Œ</div>
            <h1>í”Œë ˆì´ì–´</h1>
            <div class="status-bar">
                <div id="player-mine-counter">ë‚¨ì€ ì§€ë¢°: 40</div>
                <div id="player-timer">ì‹œê°„: 0</div>
            </div>
            <div class="game-board-wrapper"><div id="player-board" class="game-board"></div></div>
        </div>
        <div id="ai-game" class="game-instance-container">
            <div id="ai-overlay" class="board-overlay hidden">ê²Œì„ ì¢…ë£Œ</div>
            <h1>AI</h1>
            <div class="status-bar">
                <div id="ai-mine-counter">ë‚¨ì€ ì§€ë¢°: 40</div>
                <div id="ai-timer">ì‹œê°„: 0</div>
            </div>
            <div class="game-board-wrapper"><div id="ai-board" class="game-board"></div></div>
        </div>
    </div>
    
    <div id="result-message" class="hidden"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const settings = { width: 16, height: 16, mines: 40 };
        const AI_THINK_SPEED = 100;
        const AI_CARELESS_THRESHOLD = 18;
        const AI_CARELESS_MISTAKE_RATE = 0.4;

        let playerGame, aiGame, isCompetitionRunning = false, competitionTimerInterval;
        const startButton = document.getElementById('start-competition');
        const rulesModalOverlay = document.getElementById('rules-modal-overlay');

        document.getElementById('close-rules-modal').addEventListener('click', () => {
            rulesModalOverlay.classList.add('hidden');
            startButton.disabled = false;
        });

        startButton.addEventListener('click', () => {
            setupCompetition();
            startCompetition();
        });

        class GameInstance {
            constructor(idPrefix, isPlayer) {
                this.idPrefix = idPrefix; this.isPlayer = isPlayer;
                this.isBoardOver = false; this.aiInterval = null;
                this.wasJustPreviewing = false; // â˜…â˜…â˜… ë¯¸ë¦¬ë³´ê¸° í–‰ë™ ì¶”ì  í”Œë˜ê·¸
                this.boardElement = document.getElementById(`${idPrefix}-board`);
                this.mineCounterElement = document.getElementById(`${idPrefix}-mine-counter`);
                this.timerElement = document.getElementById(`${idPrefix}-timer`);
                this.overlayElement = document.getElementById(`${idPrefix}-overlay`);
            }
            
            setup() { this.board = []; this.flags = 0; this.isBoardOver = false; this.overlayElement.classList.add('hidden'); this.updateMineCounter(); this.createBoard(); }
            
            createBoard() {
                this.board = Array.from({ length: settings.height }, (_, y) => Array.from({ length: settings.width }, (_, x) => ({ y, x, isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0 })));
                this.boardElement.innerHTML = '';
                this.boardElement.style.gridTemplateColumns = `repeat(${settings.width}, 1fr)`;
                for (let y = 0; y < settings.height; y++) {
                    for (let x = 0; x < settings.width; x++) {
                        const cellElement = document.createElement('div');
                        cellElement.classList.add('cell');
                        cellElement.dataset.y = y;
                        cellElement.dataset.x = x;
                        if (this.isPlayer) {
                            cellElement.classList.add('player-cell');
                            cellElement.addEventListener('click', () => this.handleCellClick(y, x));
                            cellElement.addEventListener('contextmenu', (e) => { e.preventDefault(); this.handleRightClick(y, x); });
                            cellElement.addEventListener('mousedown', (e) => this.handleMouseDown(e, y, x));
                            cellElement.addEventListener('mouseup', () => this.clearPreview());
                            cellElement.addEventListener('mouseout', () => this.clearPreview());
                        }
                        this.boardElement.appendChild(cellElement);
                    }
                }
            }
            
            handleMouseDown(event, y, x) {
                if (event.button !== 0 || this.isBoardOver) return;
                const cellData = this.board[y][x];
                if (cellData.isRevealed && cellData.adjacentMines > 0) {
                    this.wasJustPreviewing = true; // â˜…â˜…â˜… ë¯¸ë¦¬ë³´ê¸° ì‹œì‘ì„ ì•Œë¦¼
                    this.getNeighbors(y, x).forEach(neighbor => {
                        if (!neighbor.isRevealed && !neighbor.isFlagged) {
                            this.boardElement.querySelector(`[data-y='${neighbor.y}'][data-x='${neighbor.x}']`)?.classList.add('cell-preview');
                        }
                    });
                }
            }

            clearPreview() {
                this.boardElement.querySelectorAll('.cell-preview').forEach(el => el.classList.remove('cell-preview'));
            }

            startLogic() { const startY = Math.floor(Math.random() * settings.height); const startX = Math.floor(Math.random() * settings.width); this.placeMines(startY, startX); if (!this.isPlayer) { this.revealCell(this.board[startY][startX]); this.aiInterval = setInterval(() => this.aiTurn(), AI_THINK_SPEED); } }
            placeMines(firstClickY, firstClickX) { let minesPlaced = 0; while (minesPlaced < settings.mines) { const y = Math.floor(Math.random() * settings.height); const x = Math.floor(Math.random() * settings.width); const isSafeZone = Math.abs(y - firstClickY) <= 1 && Math.abs(x - firstClickX) <= 1; if (!this.board[y][x].isMine && !(y === firstClickY && x === firstClickX) && !isSafeZone) { this.board[y][x].isMine = true; minesPlaced++; } } for (let y = 0; y < settings.height; y++) { for (let x = 0; x < settings.width; x++) { if (!this.board[y][x].isMine) this.board[y][x].adjacentMines = this.getNeighbors(y, x).filter(n => n.isMine).length; } } }
            
            handleCellClick(y, x) {
                if (!isCompetitionRunning || this.isBoardOver) return;
                
                // â˜…â˜…â˜… í•µì‹¬ ìˆ˜ì •: ë¯¸ë¦¬ë³´ê¸° ì§í›„ì˜ í´ë¦­ì€ ë¬´ì‹œ
                if (this.wasJustPreviewing) {
                    this.wasJustPreviewing = false; // í”Œë˜ê·¸ë¥¼ ë¦¬ì…‹í•˜ê³ 
                    return; // í•¨ìˆ˜ë¥¼ ì¦‰ì‹œ ì¢…ë£Œ
                }

                const cell = this.board[y][x];

                // ì—´ë¦° ì¹¸ì„ "ì§§ê²Œ" í´ë¦­í–ˆì„ ë•Œ (ì£¼ë³€ ì—´ê¸°)
                if (cell.isRevealed) {
                    if (cell.adjacentMines > 0) {
                        const neighbors = this.getNeighbors(y, x);
                        const flagCount = neighbors.filter(n => n.isFlagged).length;

                        if (flagCount === 0) { // ì•ˆì „ ëª¨ë“œ
                            neighbors.forEach(n => {
                                if (!n.isFlagged && !n.isRevealed && !n.isMine) { this.revealCell(n); }
                            });
                        } else { // ìœ„í—˜ ëª¨ë“œ
                            const hasIncorrectFlag = neighbors.some(n => n.isFlagged && !n.isMine);
                            if (hasIncorrectFlag) { this.finishBoard(); return; }
                            neighbors.forEach(n => {
                                if (!n.isFlagged && !n.isRevealed) { this.revealCell(n); }
                            });
                        }
                    }
                    return;
                }

                // ë‹«íŒ ì¹¸ì„ ì²˜ìŒ í´ë¦­í–ˆì„ ë•Œ
                if (cell.isFlagged) return;
                this.revealCell(cell);
            }

            revealCell(cell) {
                if (!cell || cell.isRevealed || cell.isFlagged) return;
                cell.isRevealed = true;
                this.revealCellDOM(cell);
                if (cell.isMine) { this.finishBoard(); return; }
                if (cell.adjacentMines === 0) {
                    this.getNeighbors(cell.y, cell.x).forEach(n => this.revealCell(n));
                }
                this.checkWin();
            }
            
            handleRightClick(y, x) {
                if (!isCompetitionRunning || this.isBoardOver || this.board[y][x].isRevealed) return;
                const cell = this.board[y][x];
                const cellElement = this.boardElement.querySelector(`[data-y='${y}'][data-x='${x}']`);
                if (cell.isFlagged) { cell.isFlagged = false; this.flags--; cellElement.innerText = ''; } else { if (this.flags >= settings.mines) { return; } cell.isFlagged = true; this.flags++; cellElement.innerText = 'ğŸš©'; }
                this.updateMineCounter();
            }

            finishBoard() { if (this.isBoardOver) return; this.isBoardOver = true; this.overlayElement.classList.remove('hidden'); if (!this.isPlayer) this.stopAI(); checkCompetitionEnd(); }
            checkWin() { const revealedCount = this.board.flat().filter(cell => cell.isRevealed).length; if (revealedCount === settings.width * settings.height - settings.mines) { this.finishBoard(); } }
            
            revealCellDOM(cell) {
                const cellElement = this.boardElement.querySelector(`[data-y='${cell.y}'][data-x='${cell.x}']`);
                if (!cellElement) return;
                cellElement.classList.add('revealed');
                if (cell.isMine) {
                    cellElement.innerText = 'ğŸ’£';
                    cellElement.classList.add('mine');
                } else if (cell.adjacentMines > 0) {
                    cellElement.innerText = cell.adjacentMines;
                    cellElement.dataset.count = cell.adjacentMines;
                }
            }

            revealFinalBoard() { this.board.flat().forEach(cell => { const cellElement = this.boardElement.querySelector(`[data-y='${cell.y}'][data-x='${cell.x}']`); if (!cellElement) return; if (cell.isFlagged && !cell.isMine) { cellElement.innerText = 'âŒ'; cellElement.classList.add('wrong-flag'); } else if (cell.isMine && !cell.isFlagged) { this.revealCellDOM(cell); } }); }
            updateMineCounter() { this.mineCounterElement.innerText = `ë‚¨ì€ ì§€ë¢°: ${settings.mines - this.flags}`; }
            getNeighbors(y, x) { const n = []; for (let yo = -1; yo <= 1; yo++) { for (let xo = -1; xo <= 1; xo++) { if (yo === 0 && xo === 0) continue; const ny = y + yo; const nx = x + xo; if (ny >= 0 && ny < settings.height && nx >= 0 && nx < settings.width) n.push(this.board[ny][nx]); } } return n; }
            stopAI() { clearInterval(this.aiInterval); }

            aiTurn() {
                if (!isCompetitionRunning || this.isBoardOver) return;
                const correctFlags = this.countCorrectFlags();
                if (correctFlags >= AI_CARELESS_THRESHOLD && Math.random() < AI_CARELESS_MISTAKE_RATE) {
                    if (this.makeSimpleGuess()) return;
                }
                if (this.makeCertainMove()) return;
                if (this.makeEducatedGuess()) return;
                this.makeRandomGuess();
            }

            countCorrectFlags() { return this.board.flat().filter(cell => cell.isFlagged && cell.isMine).length; }
            makeCertainMove() { for (const cell of this.board.flat()) { if (!cell.isRevealed || cell.adjacentMines === 0) continue; const neighbors = this.getNeighbors(cell.y, cell.x); const hidden = neighbors.filter(n => !n.isRevealed && !n.isFlagged); const flaggedCount = neighbors.filter(n => n.isFlagged).length; if (hidden.length === 0) continue; if (cell.adjacentMines - flaggedCount === hidden.length) { hidden.forEach(n => { if (!n.isFlagged) { n.isFlagged = true; this.flags++; this.boardElement.querySelector(`[data-y='${n.y}'][data-x='${n.x}']`).innerText = 'ğŸš©'; } }); this.updateMineCounter(); return true; } if (cell.adjacentMines === flaggedCount) { hidden.forEach(n => this.revealCell(n)); return true; } } return false; }
            makeEducatedGuess() { const candidates = this.board.flat().filter(c => !c.isRevealed && !c.isFlagged); let bestGuess = { cell: null, probability: 2.0 }; for (const candidate of candidates) { const numberedNeighbors = this.getNeighbors(candidate.y, candidate.x).filter(n => n.isRevealed && n.adjacentMines > 0); if (numberedNeighbors.length === 0) continue; let minProb = 1.0; for (const neighbor of numberedNeighbors) { const allNeighbors = this.getNeighbors(neighbor.y, neighbor.x); const hiddenCount = allNeighbors.filter(n => !n.isRevealed && !n.isFlagged).length; const flaggedCount = allNeighbors.filter(n => n.isFlagged).length; if (hiddenCount > 0) { const prob = (neighbor.adjacentMines - flaggedCount) / hiddenCount; minProb = Math.min(minProb, prob); } } if (minProb < bestGuess.probability) { bestGuess = { cell: candidate, probability: minProb }; } } if (bestGuess.cell && bestGuess.probability < 1) { this.revealCell(bestGuess.cell); return true; } return false; }
            makeSimpleGuess() { const candidates = []; this.board.flat().forEach(cell => { if (cell.isRevealed && cell.adjacentMines > 0) { this.getNeighbors(cell.y, cell.x).forEach(neighbor => { if (!neighbor.isRevealed && !neighbor.isFlagged) { candidates.push(neighbor); } }); } }); if (candidates.length > 0) { const randomCandidate = candidates[Math.floor(Math.random() * candidates.length)]; this.revealCell(randomCandidate); return true; } return false; }
            makeRandomGuess() { const hidden = this.board.flat().filter(c => !c.isRevealed && !c.isFlagged); if (hidden.length > 0) { this.revealCell(hidden[Math.floor(Math.random() * hidden.length)]); } }
        }

        function setupCompetition() { isCompetitionRunning = false; document.getElementById('result-message').classList.add('hidden'); clearInterval(competitionTimerInterval); playerGame = new GameInstance('player', true); aiGame = new GameInstance('ai', false); playerGame.setup(); aiGame.setup(); startButton.disabled = false; startButton.innerText = "ëŒ€ê²° ì‹œì‘"; }
        function startCompetition() { if (isCompetitionRunning) return; isCompetitionRunning = true; startButton.disabled = true; playerGame.startLogic(); aiGame.startLogic(); let time = 0; competitionTimerInterval = setInterval(() => { if (!isCompetitionRunning) { clearInterval(competitionTimerInterval); return; } time++; playerGame.timerElement.innerText = `ì‹œê°„: ${time}`; aiGame.timerElement.innerText = `ì‹œê°„: ${time}`; }, 1000); }
        function checkCompetitionEnd() { if (playerGame.isBoardOver && aiGame.isBoardOver) { isCompetitionRunning = false; showFinalResult(); } }
        function calculateCorrectFlags(board) { return board.flat().filter(cell => cell.isFlagged && cell.isMine).length; }
        function showFinalResult() { startButton.disabled = false; startButton.innerText = "ë‹¤ì‹œ ì‹œì‘"; const playerCorrectFlags = calculateCorrectFlags(playerGame.board); const aiCorrectFlags = calculateCorrectFlags(aiGame.board); let resultText = ''; let subText = `í”Œë ˆì´ì–´: ${playerCorrectFlags}ê°œ ë°œê²¬ / AI: ${aiCorrectFlags}ê°œ ë°œê²¬`; if (playerCorrectFlags === aiCorrectFlags) { resultText = 'ë¬´ìŠ¹ë¶€!'; } else if (playerCorrectFlags > aiCorrectFlags) { resultText = 'í”Œë ˆì´ì–´ ìŠ¹ë¦¬!'; } else { resultText = 'AI ìŠ¹ë¦¬!'; } document.getElementById('result-message').innerHTML = `${resultText}<small>${subText}</small>`; document.getElementById('result-message').classList.remove('hidden'); playerGame.revealFinalBoard(); aiGame.revealFinalBoard(); }
        
        new GameInstance('player', true).createBoard();
        new GameInstance('ai', false).createBoard();
        startButton.disabled = true;
    });
    </script>
</body>
</html>